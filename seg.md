---
marp: true
size: 4:3
math: mathjax
---

# Segment tree

## 用于维护幺半群区间信息的数据结构

## 功能

### $O(logN)$复杂度下实现

- 区间查询 (query)
- 区间修改 (modify)
- 支持任何符合幺半群性质的代数系统，如求和，乘法，异或，gcd，max等运算

---

## 线段树的建树 ， 我们给出一个求和代数系统下的例子

线段树将每个长度不为 1 的区间划分成左右两个区间递归求解，把整个线段划分为一个树形结构，通过合并左右两区间信息来求得该区间的信息。这种数据结构可以方便的进行大部分的区间操作。

---

![h:400 w:1000](/images/870675c4379d6654720449258cd30b1a75f0b63d6be6c0c8ef0a0a2087149505.png)  

**红色字体**表明的是该结点管辖的区间，黑色字体表示该区间维护的信息

左子结点表示: $[l,(l+r)/2]$  右子结点表示: $[(l+r)/2+1,r]$

特别的 , 当$l==r$则该结点为叶节点

---

## 性质

由线段树为CBT,即完全二叉树，存树除了可持久化线段树,一般使用堆式存储

- 树高 $\lceil logN \rceil$
- 总结点数 $2^{\lceil logn \rceil+1}$

可得总空间开销约为$4N$,空间复杂度$O(N)$

---

## 区间查询 $O(logN)$

假设查询区间为 $[l,r]$ ,从线段树根节点开始查询

### 有  

- 假设查询区间覆盖左结点，查询左子树

- 假设查询区间覆盖右结点，查询右子树

- 每次区间查询可覆盖未查询子区间 $\lfloor n/2 \rfloor$

---

## lazy tag 加速区间修改 $O(logN)$

lazy tag 的核心思想便是延迟修改，若查询过程某节点被完全覆盖，则将其修改并打上tag
**并停止向下搜索**

下面我们给出一个例子，代数系统依然为求和

---

![h:400 w:700](/images/fc1c4d8d60af4505ec2d8c751ec9632115ae5d6572130a0cc55b8ddf4c2fe81b.png)  

### 假设我们对区间 $[3,5]$ 加上5

- 从根节点向下搜索过程有 $[3,3]$ , $[4,5]$ 被查询区间**完全覆盖**
- 我们给这两个结点打上tag，修改区间后停止向下搜索

---

![h:400 w:700](/images/9d602ef3f3dc1091586296d80fdd00e4865439e9237f9635229fbaf5d985cc10.png)  

### 修改完成后假设我们需要查询区间 $[4,4]上的信息$

---

#### 我们沿着根节点路径向下搜索过程中，不断将lazy tag 下放，并将搜索路径上的tag清空，以此不断维护需要的信息

![picture 3](/images/e51340cdc04ce360a274563125806659e738ce7c8b354099198b748fc6a08be8.png)  

---

## 可持久化线段树

主席树是线段树可持久化数据结构。

即每次做 $modify$ 操作时，保留历史版本

---

## 实现方式

- 可以观察到每次做区间修改更改的结点数量约为树高

- 每次进行修改，额外增加 $logN$ 个修改过后的新结点

- 由于主席树是动态开点的思想，所以存树使用链式存储。

---

![picture 4](/images/093d693bfdbb9ddb0bd14010b0d7641d9e1f10b48e27c4eaf9c3c265a2e36408.png)  

图中红色结点为区间修改时需要更改的结点

---

## 例题

- 权值线段树加速动态规划状态转移

- 线段树结合dfs序维护子树和，实现子树修改

- 可持久化线段树实现查询区间第k大值 